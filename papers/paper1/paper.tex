\documentclass[letterpaper]{article}
\usepackage{graphicx}

\begin{document}

\title{A protocol for implementing read-only databases in dynamic distributed environments}
\author{Adam Drescher \and Magdalena Cassel}
\date{}

\maketitle

\begin{abstract}
The abstract abstract.
\end{abstract}

\section{Introduction}
The proliferation of embedded networking is transforming homes into distributed computing environments.
A variety of devices, including desktops, laptops, tablets, printers, digital picture frames, televisions, digital cameras, and optical disc players, are now equipped with wireless network interfaces.
The ability of these devices to communicate with one another is creating opportunities for applications that engage multiple devices.
Typically, these networks will consist of a small to moderate number of devices, many of which are resource-constrained.
Home networks are built up as users contribute new devices to the network.
When a new device is added, i.e., turned on, the user expects the device to be available in a timely fashion.

Applications in home networks, and other dynamic distributed systems, are often governed by immutable configuration records contributed by each node in the system.
A simple directory application might gather and display a list of all of the devices in the system.
Similarly, applications using discovery and advertisement are governed by the service specifications and descriptions contributed by service consumers and providers.
One of the tasks in the system, then, is to match specifications to descriptions for the purpose of service binding.

Both centralized and distributed algorithms have been proposed to collect and process configuration records.
Centralized algorithms elect a leader which then facilitates query processing.
The leader may perform the processing itself or delegate processing to a subordinate node.
Distributed algorithms for configuration record processing often use one of two techniques, depending on the size of the records.
If the records are bigger than the maximum size of a message, i.e., a UDP packet, nodes discover other nodes using broadcast messages and then use point-to-point connections to collect remote configuration records.
Using this approach, the $n$th node to join the network will be queried $n-1$ times.
If the records are smaller than the maximum size of a message, nodes exchange configuration records using a multicast network, e.g., the Multicast Domain Name System.

To collect and process configuration records in home networks, we require a protocol that is both fully distributed and supports records of arbitrary size.
The resource-poor nature of the devices in the network, combined with the dynamic nature of the network, implies that a fully distributed algorithm is more appropriate.
In order to do capabilities-based matching, we require the ability to support configuration records of arbitrary size.
Finally, we would like to use gossip to avoid sending duplicate records when a new node joins the network.

This paper describes the Multicast File Transfer Protocol (MFTP), a distributed dissemination protocol for home networks that supports records of arbitrary size.

%Moving data across a network can take a variety of forms. 
%These forms correspond to different user needs and consequently different protocols. 
%Multicast File Transfer Protocol (MFTP) addresses the need to move immutable data between many different nodes in a fully distributed network. 
%% This is useful for 1) device discovery 2) File transfer in the absence of many technologies (including internet). the only thing that is necessary is computers with routing and broadcast/multicast enabled 3) maximizing the reach of a gossip style network

\section{Model\label{model}}

We want to establish relationships between configuration records, which means we need to be able to download configuration records.

%% The problem of processing configuration information can be cast using relational database techniques.
%% A database consists of one or more tables, where each table consists of a number of identically structured records.
%% Database tables are manipulated by the insert, delete and update methods, which insert, delete and modify records.
%% Database tables are queried using the select operator.
%% For processing configuration information, each configuration record is mapped into a table of the appropriate type.
%% Listing all of the components in the system corresponds to selecting all of the records in the database.
%% Discovery can be accomplished by projecting a service specification record onto the table of service descriptions.

%% A record is defined by its content.
%% Consequently, each record is immutable and the update method is not allowed.
%% Configuration records are immutable and under the control of the node that stores them.



%% Each record is immutable. Update doesn't exist. The records stored on each node are under the control of that node. Insert and delete only exist locally.

%% Each table and each record has an ID
%% Each record ID consists of the ID of the table it belongs to and the length and hash of its binary representation.
%% The records are uniquely identifiable by their IDs.
%% Each node then contributes zero or more immutable records to one or more of the tables.
%% We can consider each configuration item as a record in a read-only database.

%% Each record is locally controlled
%% since immutable, can be replicated (no duplicates in the database)
%% each node has its own set of records which it contributes

Files are an abstraction of the configuration record.

\paragraph {Files.}
The main concept in MFTP is that of a \emph{file}.

A file is a sequence of bytes with a length and a user-defined type.
Files are divided into pieces of equal size called \emph{fragments}.
Each file is uniquely identified by a \emph{file ID} that contains the file's type, length, and a hash of the file's contents.

% TODO:  We need to move this.
% Given two files $f_1$ and $f_2$, one can define a matching predicate $\mu$.

\paragraph {Tasks.}
The two main tasks in MFTP are acquiring a file and establishing a relationship between two files.
The process of acquiring a file involves sending a request for the file's fragments and receiving fragments sent in response.
MFTP is a peer-to-peer protocol because each participant can act as both a client and a server.
A peer can send out any fragments for which it gets a request.
Fragments are periodically broadcast, even in the absence of requests, to indicate what files exist in the network.
A peer can use requests to poll for fragments of a file which can span from individual fragments to the whole file.
A peer which has successfully downloaded any number of fragments of a file can then serve those fragments.

Matching is a two-step process.
The first step applies a matching function $\iota$ to two file IDs to determine whether a match is possible between the two files.  
The second step applies a matching function $\mu$ to the two files to determine whether there is a match.
If $\mu$($f_1$,$f_2$) is true, $\iota$($fid_1$,$fid_2$) must be true.
However, if $\iota$($fid_1$,$fid_2$) is true, $\mu$($f_1$,$f_2$) does \emph{not} have to be true. 

\paragraph{Messages.}
File transfer takes place via \emph{messages}.
There are three types of messages in the protocol.
The first message type is a \emph{request}.
A request contains a file ID and a set of fragment indices.
We implemented requests as the file ID and a set of contiguous regions.  
However, one can envision the request to contain anything that defines a set.
The second message type is a \emph{fragment}, which consists of a file ID, a fragment index, and the data comprising that fragment of the file.
Last is a \emph{match}, which consists of a file ID and a set of matching file IDs.


%%TODO: Talk about validation

\section{Implementation}

%%TODO: Talk about validation - possible coinage 'incremental digest'

\paragraph{MFTP Automaton.}
Our implementation of MFTP uses the ioa framework.
I/O Automata model stateful distributed system components that can interact and be composed with each other.
They change state through transitions classified as input, output or internal actions.
Input and output actions in different automata are bound; output actions in the one trigger input actions in the other.

%%Describe our implementation at the 50k ft view and work our way down until things are no longer interesting.
We define a basic MFTP automaton, a sender, and a receiver.
The responsibilities of the MFTP automaton are to acquire data and to help others acquire it.
Each MFTP automaton begins with a file, encapsulated in a File object, which is either incomplete or complete.
If the file is incomplete, the automaton generates requests for the missing fragments.
If the file is complete, the automaton may serve the file, or it may serve the file while performing matching on it.

%%Picture of mFTP automaton?

MFTP automata receive messages via the receive input action.
If the input message is a valid fragment of its own file, the automaton saves the fragment.
If the input message is a request for fragments of its file, it flags those fragments as having been requested.
If the input message is a match containing its file ID, it records the matching IDs for download.

The automaton holds a queue of one message to send. 
The internal actions which fill this queue are triggered periodically.
The automaton generates messages containing one requested fragment if any fragments in the file have been requested.
The fragment sent is selected at random to help avoid collisions with other MFTP automata serving the same file.
The automaton generates requests if some fragments in the automaton's own file are missing.
The automaton generates match messages if it has recorded any matches to its file.

The automaton reports that its file is complete using the download complete output action.

\paragraph{Matching.}
Each MFTP automaton contains a flag that determines whether it will perform matching. 
It has another flag that determines whether it will self-destruct when it has finished downloading its file.
If the matching flag is set, the automaton applies the matching function $\iota$ to the file IDs of incoming fragments.
If $\iota$ is true, the automaton recursively constructs another MFTP automaton to download the potential match.
This child automaton does not perform matching.  
Its self-destruct flag is set so that it will self-destruct once the potential match has been downloaded.
When the download is complete, the parent automaton applies the matching function $\mu$ to the file to determine whether it is a match.

\paragraph{Some useful stuff.} %% We know it's rough, but what else can we do?
The sending automaton uses the UDP sender built into ioa to multicast messages one at a time.
The receiving automaton uses the ioa UDP receiver.
The sender and receiver automata may be connected to more than one MFTP automaton.

\vspace{5mm}
\includegraphics[scale=0.65]{diagramOne}

\paragraph{Jam.} %%needs different header
Our implementation defines three file types, \emph{data}, \emph{meta} and \emph{query}.  
A data file contains data from any file in the network.
A meta file contains as data the file ID of a file in the network and its name. 
A query file contains only the name of the file which is being queried.

We wrote two programs, \emph{Share} and \emph{Get}, which use MFTP, sender and receiver automata to disseminate a file or files. %%Can one 'disseminate' a file?
Share creates two MFTP automata, \emph{file server} and \emph{meta server}.
File server is constructed with a complete file \emph{f}, and meta server is constructed with a meta file.
The meta file is generated from the fileID and name of f.
At the start, Get creates one MFTP automaton, \emph{query server}, constructed with a query file.
The query file is generated from the name of the file to download, supplied by a command line argument.

We defined a functor interface so that Share and Get could use different $\iota$ and $\mu$ functions.
In Share, meta server performs matching on the meta file and broadcasts matches to f.
Its $\iota$ returns true if the incoming file is a query file.
Its $\mu$ returns true if the contents of the downloaded query file match the name of f.

\vspace{2 mm}

\includegraphics[scale=0.55]{share_diagram}

\vspace{2 mm}

In Get, query server performs matching on the query file.
Its $\iota$ returns true if the incoming file is a meta file.
Its $\mu$ returns true if the contents of the downloaded meta file match the name of the file being queried.
Query server passes the meta files downloaded by its child automata to Get.
Using the file IDs contained in the meta files, Get constructs further MFTP automata which download the files pertaining to those file IDs.

\vspace{2.5 mm}

\includegraphics[scale=0.65]{get_diagram}

\vspace{2 mm}

%%\begin{itemize}
%%  \item Problem
%%  \item Design forces
%%  \item Solution
%%  \item Consequences
%%\end{itemize}

\section{Evaluation and Discussion\label{evaluation}}

\begin{itemize}
\item Translation of automaton in \emph{Distributed Algorithms} to C++.
\item Simulate a protocol then replace with network components
\item Compare a protocol using: single-threaded event-based (select loop), multi-threaded, I/O automata
\item Show a buggy program and then apply an invariant to find the bug.
\end{itemize}

Bring up style mentioned in section \ref{representation}.

\section{Related Work\label{related_work}}

pthreads (?)
Edward Lee - The Problem with Threads
Herb Sutter - The Free Lunch is Over
Early work on concurrency

\section{Conclusion and Future Work\label{conclusion}}

\begin{itemize}
  \item We are going to use it to build the substrate.
  \item Speculate on moving down into operating system (device drivers would be easy, IPC including filesystem replaced by automata)
  \item Speculate on moving down into the hardware level (Local talent, Ivan Sutherland)
  \item We can take advantage of multi-core in a very straight-forward way
  \item New problems in scheduling (Pinning automata to processors to minimize actions that span two processors.  Maximum independent set.)
  \item We are non-blocking all the way.  Combine this with a deterministic implementation of the scheduler and model and there are serious opportunities for real-time.
\end{itemize}

\end{document}
